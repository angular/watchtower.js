{"version":3,"file":"watch_record.js","sources":["@traceur/generated/TemplateParser/7","watch_record.js","@traceur/generated/TemplateParser/6","@traceur/generated/TemplateParser/5","@traceur/generated/TemplateParser/4","@traceur/generated/TemplateParser/8","@traceur/generated/TemplateParser/9","@traceur/generated/TemplateParser/10","@traceur/generated/TemplateParser/12","@traceur/generated/TemplateParser/11","@traceur/generated/TemplateParser/3","@traceur/generated/TemplateParser/1","@traceur/generated/TemplateParser/2"],"names":[],"mappings":"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","sourcesContent":["define($__placeholder__0, $__placeholder__1);","import {\n  _LinkedList,\n  _LinkedListItem,\n  _WatchList,\n  _ArgHandlerList,\n  _EvalWatchList\n} from './linked_list';\n\nimport {\n  Watch\n} from './watch';\n\nvar haveMap = (typeof WeakMap === \"function\" && typeof Map === \"function\");\n\nclass _Handler {\n  constructor(watchGrp, expression) {\n    _LinkedList._initialize(this);\n    _LinkedListItem._initialize(this);\n    _WatchList._initialize(this);\n\n    this.watchGrp = watchGrp;\n    this.expression = expression;\n    this.watchRecord = this.forwardingHandler = null;\n  }\n\n  addReactionFn(reactionFn) {\n    // TODO: Traceur assertions\n    // assert(this._next !== this);\n    // assert(typeof reactionFn === \"function\");\n    return this.watchGrp._rootGroup._addDirtyWatch(_WatchList._add(this,\n      new Watch(this.watchGrp, this.watchRecord, reactionFn)));\n  }\n\n  addForwardHandler(forwardToHandler) {\n    // TODO: Traceur assertions\n    // assert(forwardToHandler.forwardingHandler === null);\n    _LinkedList._add(this, forwardToHandler);\n    forwardToHandler.forwardingHandler = this;\n  }\n\n  // I'm not sure this really makes sense in JS, since we don't actually know when finallization\n  // occurs. I think this is called manually in a few areas though, so I'll leave it for now.\n  release() {\n    if (_WatchList._isEmpty(this) && _LinkedList._isEmpty(this)) {\n      this._releaseWatch();\n\n      // Remove outselves from cache, or else new registrations will go to us, but we are dead\n      // Potential GC pressure...\n      if (this.watchGrp) {\n        delete this.watchGrp._cache[this.expression];\n      }\n\n      if (this.forwardingHandler !== null) {\n        // TODO(misko): why do we need this check? --- Because _LinkedList._remove() manipulates\n        // properties of the list, and it will be referencing properties of null and throw a\n        // noSuchMethod error if forwardingHandler === null\n        _LinkedList._remove(this.forwardingHandler, this);\n        this.forwardingHandler.release();\n        this.forwardingHandler = null;\n      }\n\n      // We can remove ourselves\n      this._next = this._previous = this;\n    }\n  }\n\n  _releaseWatch() {\n    this.watchRecord.remove();\n    this.watchGrp._fieldCost--;\n  }\n\n  acceptValue(object) {\n    return null;\n  }\n\n  onChange(record) {\n    // TODO: Traceur assertions\n    // assert(this._next !== this); // Verify we are not detached\n\n    // If we have reaction functions, then queue them up for asynchronous processing.\n    var watch = this._watchHead;\n    var root = this.watchGrp._rootGroup;\n    while (watch !== null) {\n      root._addDirtyWatch(watch);\n      watch = watch._nextWatch;\n    }\n\n    // If we have a delegateHandler, then forward the new value to it.\n    var delegateHandler = this._head;\n    while (delegateHandler !== null) {\n      delegateHandler.acceptValue(record.currentValue);\n      delegateHandler = delegateHandler._next;\n    }\n  }\n}\n\nexport class _ConstantHandler extends _Handler {\n  constructor(watchGroup, expression, constantValue) {\n    super(watchGroup, expression);\n    this.watchRecord = new _EvalWatchRecord.constant(this, constantValue);\n  }\n\n  release() {\n    return null;\n  }\n}\n\nexport class _FieldHandler extends _Handler {\n  constructor(watchGroup, expression) {\n    super(watchGroup, expression);\n  }\n\n  // This function forwards the watched object to the next [_Handler] synchronously\n  acceptValue(object) {\n    this.watchRecord.object = object;\n    if (this.watchRecord.check()) this.onChange(this.watchRecord);\n  }\n}\n\nexport class _CollectionHandler extends _Handler {\n  constructor(watchGroup, expression) {\n    super(watchGroup, expression);\n  }\n\n  // This function forwards the watched object to the next [_Handler] synchronously\n  acceptValue(object) {\n    this.watchRecord.object = object;\n    if (this.watchRecord.check()) this.onChange(this.watchRecord);\n  }\n\n  _releaseWatch() {\n    this.watchRecord.remove();\n    this.watchGrp._collectionCost--;\n  }\n}\n\nexport class _ArgHandler extends _Handler {\n  constructor(watchGroup, watchRecord, index) {\n    // TODO(caitp): assert that watchRecord is an _EvalWatchRecord?\n    super(watchGroup, 'arg[' + index + ']');\n    this._previousArgHandler = this._nextArgHandler = null;\n    this.watchRecord = watchRecord;\n    this.index = index;\n  }\n\n  _releaseWatch() {\n    return null;\n  }\n\n  acceptValue(object) {\n    this.watchRecord.dirtyArgs = true;\n    this.watchRecord.args[this.index] = object;\n  }\n}\n\nexport class _InvokeHandler extends _Handler {\n  constructor(watchGroup, expression) {\n    super(watchGroup, expression);\n    _ArgHandlerList._initialize(this);\n  }\n\n  acceptValue(object) {\n    this.watchRecord.object = object;\n  }\n\n  release() {\n    super.release();\n    var current = this._argHandlerHead;\n    while (current !== null) {\n      current.release();\n      current = current._nextArgHandler;\n    }\n    // TODO(caitp): should _argHandlerHead/Tail be nulled here? Or would that cause too much GC\n    // pressure.\n  }\n\n  _releaseWatch() {\n    this.watchRecord.remove();\n    // TODO(caitp): why return undefined here?\n  }\n}\n\nvar _MODE_DELETED_ = -1;\nvar _MODE_MARKER_ = 0;\nvar _MODE_FUNCTION_ = 1;\nvar _MODE_FUNCTION_APPLY_ = 2;\nvar _MODE_NULL_ = 3;\nvar _MODE_FIELD_CLOSURE_ = 4;\nvar _MODE_MAP_CLOSURE_ = 5;\nvar _MODE_METHOD_ = 6;\n\n// TODO(caitp): This does not seem like the correct module for _EvalWatchRecord to live\nexport class _EvalWatchRecord {\n  constructor(watchGrp, handler, fn, name, arity, marker) {\n    this.watchGrp = watchGrp;\n    this.handler = handler;\n    this.name = name;\n    this.fn = fn;\n    // TODO(caitp): The ES6 draft is not super clear about what can be done with Symbols.\n    // This may be entirely unnecessary.\n    // this.symbol = name === null ? null : new Symbol(name);\n    this._prevEvalWatch = this._nextEvalWatch = null;\n\n    if (marker === true) return;\n    this.args = new Array(arity);\n\n    // TODO(caitp): Does the FunctionApply type really need to be implemented?\n    if (typeof fn === 'function') {\n      this.mode = _MODE_FUNCTION_;\n    } else {\n      this.mode = _MODE_NULL_;\n    }\n  }\n\n  static marker() {\n    var record = new _EvalWatchRecord(null, null, null, null, null, true);\n    record.args = null;\n    record.mode = _MODE_MARKER_;\n    return record;\n  }\n\n  static constant(handler, constantValue) {\n    var record = _EvalWatchRecord.marker();\n    record.currentValue = constantValue;\n    record.handler = handler;\n    return record;\n  }\n\n  get field() {\n    // TODO(caitp): does this look right for javascript? Some other representation might make more\n    // sense.\n    return '()';\n  }\n\n  get object() {\n    return this._object;\n  }\n\n  set object(value) {\n    // TODO(caitp): Traceur assertions\n    // assert(this.mode !== _MODE_DeLETED_);\n    // assert(this.mode !== _MODE_MARKER_);\n    // assert(this.mode !== _MODE_FUNCTION_);\n    // assert(this.mode !== _MODE_FUNCTION_APPLY_);\n    // assert(this.symbol !== null);\n    this._object = value;\n\n    if (value === null) {\n      this.mode = _MODE_NULL_;\n    } else {\n      if (haveMap && (value instanceof Map || value instanceof WeakMap)) {\n        this.mode = _MODE_MAP_CLOSURE_;\n      } else if (this.name) {\n        this.mode = _MODE_METHOD_;\n      }\n    }\n    /**\n     * TODO(caitp): The usefulness of these blocks is yet to be discovered, but I'm sure it's out\n     * there somewhere.\n     *\n     * else {\n     *   if (value instanceof Map) {\n     *     this.mode = _MODE_MAP_CLOSURE_;\n     *   } else {\n     *     this._instanceMirror = this.reflect(value);\n     *     this.mode = this._hasMethod(this._instanceMirror, this.symbol)\n     *               ? _MODE_METHOD_\n     *               : _MODE_FIELD_CLOSURE_;\n     *   }\n     * }\n     */\n  }\n\n  check() {\n    var value;\n    switch (this.mode) {\n    case _MODE_MARKER_:\n    case _MODE_NULL_:\n      return false;\n    case _MODE_FUNCTION_:\n      if (!this.dirtyArgs) return false;\n      value = this.fn.apply(null, this.args);\n      this.dirtyArgs = false;\n      break;\n    case _MODE_METHOD_:\n      value = methodInvoke(this._object, this.name, this.args);\n      break;\n    // TODO: the rest of these items don't really make sense in JS, as far as I can tell.\n    // Investigate and ask about this.\n    default:\n      throw \"UNREACHABLE\";\n    }\n\n    var current = this.currentValue;\n    if (current !== value) {\n      if (current !== current && value !== value) {\n        // Ignore, it appears to be a NaN -> NaN change.\n        current = value;\n      } else {\n        this.previousValue = current;\n        this.currentValue = value;\n        this.handler.onChange(this);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  get nextChange() {\n    // TODO(caitp): Investigate this, it doesn't seem to make a lot of sense. Is this because it\n    // lives in the evalWatchList rather than a different sort of list?\n    return null;\n  }\n\n  remove() {\n    // TODO(caitp): Traceur assertions\n    // assert(this.mode !== _MODE_DELETED_);\n    this.mode = _MODE_DELETED_;\n    this.watchGrp._evalCost--;\n    _EvalWatchList._remove(this.watchGrp, this);\n  }\n\n  toString() {\n    if (this.mode === _MODE_MARKER_) return 'MARKER[' + this.currentValue + ']';\n    return '' + this.watchGrp.id + ':' + this.handler.expression;\n  }\n\n  // TODO(caitp): worry about this later...\n  // static _hasMethod(mirror, symbol) {\n  //   return mirror.type.instanceMembers[symbol] is MethodMirror;\n  // }\n}\n\nvar __no_args__ = [];\nfunction methodInvoke(object, method, args) {\n  if (object || (typeof object !== 'undefined' && object !== null)) {\n    if (typeof object[method] === \"function\") {\n      return object[method].apply(object, args || __no_args__);\n    }\n  }\n}\n","function($__placeholder__0) {\n      $__placeholder__1\n    }","var __moduleName = $__placeholder__0;","if (!$__placeholder__0 || !$__placeholder__1.__esModule)\n            $__placeholder__2 = { 'default': $__placeholder__3 }","var $__placeholder__0 = $__placeholder__1","($traceurRuntime.createClass)($__placeholder__0, $__placeholder__1, $__placeholder__2)","$traceurRuntime.superCall($__placeholder__0, $__placeholder__1, $__placeholder__2,\n                                   $__placeholder__3)","var $__placeholder__0 = $__placeholder__1","($traceurRuntime.createClass)($__placeholder__0, $__placeholder__1, $__placeholder__2,\n                                       $__placeholder__3)","return $__placeholder__0","get $__placeholder__0() { return $__placeholder__1; }","__esModule: true"]}